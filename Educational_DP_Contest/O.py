"""
O - Matching

考え方:
    1 ～ 2^N までの数値を用意し, それぞれの状態を 1 ～ b' 番目までの男性がマッチング完了した状態と定義する.
    この時, b' は n' を2進数で表した時の 1 bit の和とする.
    また, n' の i 桁目のビットが 1 であれば i 番目の女性はマッチング済みとする.
    ここで n' の状態が X 件成立する場合, n'' = b' + 1 を満たすすべての n に対して, n' から新たに増えたビット部分の女性とマッチングが可能であれば n'' でも X 件が成立するといえる.
    これを連続して計算することで最終的にすべての男女がマッチングする組み合わせの件数が求められる.

提出1回目:
    速度不足. 何か例外的なパターンではじかれた模様.
    もっと早い言語で書き直したほうがいいのだろうか...
    あとどんなパターンだとだめなのかわからん...
提出2回目:
    初期値(マッチング対象無しの場合)を 1 とすることで bit count 処理を省略.
    1回目ではじかれたのはおそらく N = 1, 相性 1 のパターン(1回目だと出力が 0 だった).
    これでもN=21の時には速度的にアウトっぽいけど一応提出してみよう.
    -> やっぱダメだった. C あたりでリライトしてみよ.

"""


def solve():
    # データ読込
    N = int(input())
    compatibility = [[int(i) for i in input().split()] for _ in range(N)]
    # dp のデータ格納用配列の作成
    dp = [0] * (2 ** N)  # 初期値は 0(件)
    dp[0] = 1
    # 配列をループ
    for i in range(len(dp) - 1):
        man_num = bin(i).count('1')
        # 現状に1組追加したパターンに組み合わせ数を追加
        if dp[i] == 0:
            continue
        for j in range(N):
            if (i >> j) % 2 != 1:
                if compatibility[man_num][j] == 1:
                    dp[i | (2 ** j)] += dp[i]

    # 結果出力
    print(dp[-1] % (10 ** 9 + 7))
    pass


if __name__ == '__main__':
    solve()
